#include <stdio.h>#include <string.h>#include <math.h>#include <stdlib.h>#include <stddef.h>#define K 		1.8 		/* Latent heat */#define TAU 	0.0003 		/* PF relaxation time */#define EPS 	0.01 		/* interfacial width */#define DELTA 	0.02 		/* modulation of the interfacial width */#define ANGLE0	1.57 		/* orientation of the anisotropy axis */#define ANISO 	6.0 		/* anisotropy 2*PI/ANISO */#define ALPHA 	0.9 		/* m(T) = ALPHA/PI * atan(GAMMA*(TEQ-T)) */#define GAMMA 	10.0#define TEQ 	1.0 		/* melting temperature */#define NX 		300 		/* size of the mesh NX*NY */#define NY 		300#define H 		0.03 		/* spatial resolution */#define DT 		2.e-4 		/* temporal resolution */#define NTIME 	1500 		/* number of time steps */#define PI 		3.14159265358#define	NR_END	1struct vec2D { double x, y;};struct vec2D	grad_theta[NX][NY], grad_eps2;double	**dmatrix(long nrl, long nrh, long ncl, long nch); /* added from numerical recipies to avoid >32k error */double *dvector(long nl, long nh);void nrerror(char error_text[]);double get_angle( double x, double y ){	double angle;	if (x==0.0) 	angle = (y>0.0 ? 0.5*PI : -0.5*PI);	else if (x>0.0)	angle = (y>0.0 ? atan(y/x) : 2.0*PI + atan(y/x));	else 			angle = PI + atan(y/x);	return angle; };	main(int argc, char *argv[]){	int 			i, j, t, ip, im, jp, jm;	double			**theta, **T, **eps2, **lap_T, **lap_theta, m;	double			**ax,**ay, epsilon, epsilon_prime, angle, tet, dydx, dxdy, scal;	FILE 			*fp;	char 			file[100];		printf("Starting the run for %d x %d mesh \n", NX,NY);	theta=dmatrix(0,NX-1,0,NY-1);	T=dmatrix(0,NX-1,0,NY-1);	eps2=dmatrix(0,NX-1,0,NY-1);	lap_T=dmatrix(0,NX-1,0,NY-1);	lap_theta=dmatrix(0,NX-1,0,NY-1);	ax=dmatrix(0,NX-1,0,NY-1);	ay=dmatrix(0,NX-1,0,NY-1);/* initial configuration: T=0 and theta=1 in a cercle of radius 3H (0 elsewhere). */	for(i=0;i<NX;i++) for(j=0;j<NY;j++) {T[i][j] = 0.0;			theta[i][j] = ((i-NX/2)*(i-NX/2)+(j-NY/2)*(j-NY/2)<10)?1.0:0.0;}		/* temporal evolution */	for (t=0;t<NTIME;t++) {		printf ("doing time step %d of %d\n",t+1,NTIME);		/* computation of various auxiliary quantities */		for (i=0;i<NX;i++){ for (j=0;j<NY;j++){			ip = (i+1)%NX; 		/* i+1 with Periodic Boundaries */			im = (NX+i-1)%NX; 	/* i-1 with Periodic Boundaries */			jp = (j+1)%NY; 		/* j+1 with Periodic Boundaries */			jm = (NY+j-1)%NY; 	/* j-1 with Periodic Boundaries */				/* gradient and laplacians (order H^2, 9 points isotropic version for laplacians) */			grad_theta[i][j].x = (theta[ip][j] - theta[im][j])/H;			grad_theta[i][j].y = (theta[i][jp] - theta[i][jm])/H;						lap_theta[i][j] = (2.0*(theta[ip][j]+theta[im][j]+theta[i][jp]+theta[i][jm]) +theta[ip][jp]+theta[im][jm]+theta[im][jp]+theta[ip][jm] - 12.0*theta[i][j])/(3.0*H*H);			lap_T[i][j] = (2.0*(T[ip][j]+T[im][j]+T[i][jp]+T[i][jm])+T[ip][jp]+T[im][jm]+T[im][jp]+T[ip][jm] - 12.0*T[i][j])/(3.0*H*H);		/* angular dependence of the interfacial width "espilon" */			angle = get_angle(grad_theta[i][j].x,grad_theta[i][j].y);			epsilon = EPS*(1.0 + DELTA*cos(ANISO*(angle-ANGLE0)));			epsilon_prime = -EPS*ANISO*DELTA*sin(ANISO*(angle-ANGLE0));		/* auxiliary quantities appearing in the phase field equation */			ay[i][j] = - epsilon*epsilon_prime * grad_theta[i][j].y;			ax[i][j] = epsilon*epsilon_prime * grad_theta[i][j].x;			eps2[i][j] = epsilon*epsilon;	}}		/* simple Euler step */	for (i=0;i<NX;i++){ 		for (j=0;j<NY;j++){		/* first, some few spatial derivatives */			ip = (i+1)%NX;			im = (NX+i-1)%NX;			jp = (j+1)%NY;			jm = (NY+j-1)%NY;					dxdy = (ay[ip][j] - ay[im][j])/H;			dydx = (ax[i][jp] - ax[i][jm])/H;			grad_eps2.x = (eps2[ip][j] - eps2[im][j])/H;			grad_eps2.y = (eps2[i][jp] - eps2[i][jm])/H;					tet = theta[i][j];			m = ALPHA/PI * atan(GAMMA*(TEQ-T[i][j]));			scal= grad_eps2.x*grad_theta[i][j].x+ grad_eps2.y*grad_theta[i][j].y;			/* Euler step */			theta[i][j] += (dxdy+dydx + eps2[i][j]*lap_theta[i][j] + scal + tet*(1.0-tet)*(tet-0.5+m))*DT/TAU;			T[i][j] += lap_T[i][j]*DT + K*(theta[i][j] - tet);	}}	}	/* saving results 	sprintf(file,"theta.dat"); fp = fopen(file,"w");	for (i=0;i<NX;i++) for (j=0;j<NY;j++) fprintf(fp," %d %d %e\n",i,j,theta[i][j]);	fclose(fp);	sprintf(file,"T.dat"); fp = fopen(file,"w");	for (i=0;i<NX;i++) for (j=0;j<NY;j++) fprintf(fp," %d %d %e\n",i,j,T[i][j]);	fclose(fp); */		sprintf(file,"theta.txt"); fp = fopen(file,"w");	for (i=0;i<NX;i++) {		for (j=0;j<NY;j++) 			fprintf(fp,"%e ",theta[i][j]);		fprintf(fp,"\n");	}	fclose(fp);	sprintf(file,"T.txt"); fp = fopen(file,"w");	for (i=0;i<NX;i++) {		for (j=0;j<NY;j++) 			fprintf(fp,"%e ",T[i][j]);		fprintf(fp,"\n");	}	fclose(fp); 		printf("\nfinished\n");}double	**dmatrix(long nrl, long nrh, long ncl, long nch){	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;	double **m;		/*allocate pointers to rows*/	m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));	if (!m) nrerror("allocation failure 1 in matrix()\n");	m += NR_END;	m -= nrl;		/*allocate rows and set pointers to them */	m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));	m[nrl] += NR_END;	m[nrl] -= ncl;		for (i=nrl+1;i<=nrh;i++)	m[i]=m[i-1]+ncol;	return m;}double *dvector(long nl, long nh){	double	*v;		v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));	if (!v) nrerror("allocation failure in dvector()\n");	return v-nl+NR_END;}void nrerror(char error_text[]){	printf("Numerical Recipes run-time error ...\n");	printf("%s\n", error_text);	printf("Now exiting system.....\n");	exit(1);}